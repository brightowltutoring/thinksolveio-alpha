/// <reference types="@sveltejs/kit" />
/// <reference lib="WebWorker" />
const sw = self as unknown as ServiceWorkerGlobalScope;

import { build, files, version } from '$service-worker';
import { error } from '@sveltejs/kit';
// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory

const CACHE = `cache-${version}`;
const ASSETS = [...build, ...files];
const STATIC_ASSETS = new Set(ASSETS);

//const isDev = import.meta.env.MODE === 'development';

// listeners
sw.addEventListener('install', (event: ExtendableEvent) => {
	event.waitUntil(addFilesToCacheAndSkipWaiting());
});
sw.addEventListener('activate', (event: ExtendableEvent) => {
	event.waitUntil(deleteOldCachesAndClaimClients());
});

// sw.addEventListener('fetch', handleCacheRequest);
sw.addEventListener('fetch', handleCacheRequestWIP);

// helpers
async function addFilesToCacheAndSkipWaiting() {
	const cache = await caches.open(CACHE);
	await cache.addAll(ASSETS);
	await sw.skipWaiting();
	console.log('A: Added file to cache');
}

async function deleteOldCachesAndClaimClients() {
	for (const key of await caches.keys()) {
		if (key !== CACHE) await caches.delete(key);
	}
	await sw.clients.claim();
	console.log('B: Delete old cache ');
}

function handleCacheRequestWIP(event: FetchEvent) {
	// if (isDev) return // no caching in dev mode

	const url = new URL(event.request.url);
	if (!url.protocol.startsWith('http')) return; // chrome to shutup in dev tools
	if (url.pathname.startsWith('/api')) return;

	const request = event.request;
	if (request.method !== 'GET') return;

	event.respondWith(respond());

	async function respond() {
		const cache = await caches.open(CACHE);

		// `build`/`files` can always be served from the cache
		// if (ASSETS.includes(url.pathname)) {
		if (STATIC_ASSETS.has(url.pathname)) {
			const response = await cache.match(url.pathname);

			if (response) {
				console.log(`Message 1: Static asset from cache: ${url.pathname}`);
				return response;
			}
		}

		// for everything else, try the network first, but
		// fall back to the cache if we're offline
		try {
			const response = await fetch(request);

			// if we're offline, fetch can return a value that is not a Response
			// instead of throwing - and we can't pass this non-Response to respondWith
			if (!(response instanceof Response)) {
				throw new Error('invalid response from fetch');
			}

			if (response.status === 200) {
				cache.put(event.request, response.clone());
			}

			console.log(`Message 2: hit network ${url.pathname}`);
			return response;
		} catch (err) {
			const response = await cache.match(request);

			if (response) {
				console.log(`Message 3: hit da cache box ${url.pathname}`);
				return response;
			}

			// if there's no cache, then just error out
			// as there is nothing we can do to respond to this request

			// TESTING 1
			return new Response(
				'Oops there was an error. Try navigating back or come back again later.',
				{
					status: 408, // khromov ??
					headers: { 'Content-Type': 'text/html' }
				}
			);

			// TESTING 2
			// throw err;

			// TESTING 3
			// error(404, 'Not found bro');

			// TESTING 4
			// return new Response('', {
			// 	status: 302,
			// 	headers: {
			// 		'Location': '/'
			// 	}
			// });
		}
	}
}

//async function fetchAndCache(request: Request) {
//	const cache = await caches.open(`offline-${version}`);
//	try {
//		const response = await fetch(request);
//
//		if (!(response instanceof Response)) {
//			throw new Error('invalid response from fetch');
//		}
//
//		if (response.status === 200) {
//			cache.put(request, response.clone());
//		}
//
//		return response;
//	} catch (err) {
//		const response = await cache.match(request);
//		if (response) return response;
//
//		throw err;
//	}
//}

//function handleCacheRequest(event: FetchEvent) {
//	const request = event.request;
//	const url = new URL(request.url);
//
//
//	const no_cachey = request.method !== 'GET'
//		|| request.headers.has('range')
//		|| url.pathname.startsWith('/api')
//
//	if (no_cachey) {
//		console.log('dont hit cache');
//		return
//	}
//
//
//	// don't try to handle e.g. data: URIs
//	const isHttp = url.protocol.startsWith('http');
//	const isDevServerRequest = import.meta.env.MODE === 'development'
//	// const isDevServerRequest = url.hostname === sw.location.hostname && url.port !== sw.location.port;
//	const isStaticAsset = url.host === sw.location.host && STATIC_ASSETS.has(url.pathname);
//	const skipBecauseUncached = request.cache === 'only-if-cached' && !isStaticAsset;
//
//
//	// for testing purposes
//	// if (!sw.navigator.onLine) {
//	// 	event.respondWith(serverGoBrrr());
//
//	// 	function serverGoBrrr() {
//	// 		console.log('offline bros .. server go brp')
//	// 		return new Response(`<html><body><h1>server go brrrrrrrr</h1></body></html>`, {
//	// 			status: 555,
//	// 			statusText: "Server Go Brrr Boi",
//	// 			headers: {
//	// 				"content-type": "text/html",
//	// 			}
//
//	// 		})
//	// 	}
//	// }
//	// for testing purposes
//
//	if (isHttp && !skipBecauseUncached) {
//		// if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
//		console.log('hit cache');
//		event.respondWith(
//			(async () => {
//				// always serve static files and bundler-generated assets from cache.
//				// if your application has other URLs with data that will never change,
//				// set this variable to true for them and they will only be fetched once.
//				const cachedAsset = isStaticAsset && (await caches.match(request));
//
//				return cachedAsset || fetchAndCache(request);
//			})()
//		);
//	}
//
//}
